---
export interface Props {
	game: string;
	category?: string; // Can be either category ID or category name
	showCategorySelector?: boolean; // Controls visibility of category dropdown
}

const { game, category, showCategorySelector = false } = Astro.props;

// Type definitions
interface Category {
	id: string;
	name: string;
}

interface SpeedrunRun {
	player: string;
	igt: string;
	date: string;
	platform: string;
	category?: string; // Optional since it's not displayed in table
}

// Game ID mapping
const GAME_IDS: Record<string, string> = {
	bloodborne: "9d3kqg1l",
	darksouls: "w6jve26j",
	darksouls2: "m1zky010",
	darksouls3: "k6qg0xdg",
	demonssouls: "m1mn8kd2",
	ds1remaster: "lde3woe6",
	ds2sotfs: "y65lw01e",
	desremake: "j1neogy1",
	eldenring: "nd28z0ed"
};

// Category definitions for each game
const GAME_CATEGORIES: Record<string, Category[]> = {
	eldenring: [
		{ id: "02qr00pk", name: "Any%" },
		{ id: "jdr4mmn2", name: "Defeat Consort" },
		{ id: "mke64j2d", name: "Two Gods" },
		{ id: "jdzzjjrd", name: "All Remembrances" },
		{ id: "824833gk", name: "All Remembrances (No DLC)" },
		{ id: "7dgpjjgd", name: "Console" },
		{ id: "7kjwnn3d", name: "All Achievements" },
		{ id: "mkey0882", name: "Any% No Wrong Warp (Archived)" },
		{ id: "wdmrgrxk", name: "Deprecated" }
	],
	// Add other games' categories as needed
	bloodborne: [
		{ id: "wk6l0pk1", name: "Any% Current Patch" },
		{ id: "xd1rqzrk", name: "All Bosses" },
		{ id: "w20omz2n", name: "Any% Glitchless" },
		{ id: "7dg693gk", name: "All Bosses Glitchless" },
		{ id: "jdr1zol2", name: "Any% Blood Level 4" },
		{ id: "vdoql56k", name: "All Bosses Blood Level 4" },
		{ id: "02q8vz92", name: "All Trophies" }
	],
	darksouls: [
		{ id: "7dg75ld4", name: "Any% No Wrong Warp" },
		{ id: "xk9zng20", name: "Any% Force Quit" },
		{ id: "mke7jn26", name: "All Bosses" },
		{ id: "zd3l9qnd", name: "All Achievements" },
		{ id: "xd1e44r2", name: "100%" },
		{ id: "ndx1pwo2", name: "Soul Level 1" },
		{ id: "mke153n2", name: "New Game+" },
		{ id: "wdm841e2", name: "Artorias of the Abyss" },
		{ id: "vdo3qe6d", name: "Least Bosses" },
		{ id: "zdn107qk", name: "Lord of the Rings" },
		{ id: "5dw8yrgd", name: "All Bosses No DLC" }
	],
	darksouls2: [
		{ id: "jdzv9gkv", name: "Any% Current Patch" },
		{ id: "xk9nr620", name: "All Bosses" },
		{ id: "5dw84ndg", name: "Old Souls (CP)" },
		{ id: "824x47wd", name: "All Bosses No DLC" },
		{ id: "q258ngg2", name: "All Achievements" }
	],
	darksouls3: [
		{ id: "7kjz1ond", name: "All Bosses" },
		{ id: "jdz6v9v2", name: "Any% Glitchless" },
		{ id: "02qml3pd", name: "All Bosses Glitchless" },
		{ id: "xk9lx0gk", name: "Any% Restricted" },
		{ id: "jdzvw3xk", name: "Any% CP" },
		{ id: "xk9r81gk", name: "All Bosses (No DLC)" },
		{ id: "vdoqy06k", name: "All Bosses (SL1)" }
	],
	demonssouls: [
		{ id: "wk64grxd", name: "Any% Glitchless" },
		{ id: "9d83j762", name: "Any% SL1" },
		{ id: "w20zlmjd", name: "All Trophies" },
		{ id: "ndxpx5o2", name: "Any% Glitchless (RTA Legacy)" }
	],
	ds1remaster: [
		{ id: "ndx1pm52", name: "Any%" },
		{ id: "wdm84w52", name: "No Wrong Warp" },
		{ id: "xd173pzd", name: "Any% Force Quit" },
		{ id: "vdo3qoyd", name: "All Bosses" },
		{ id: "w20vqvvk", name: "All Achievements" },
		{ id: "xd1vlqzd", name: "Glitchless" },
		{ id: "9d839032", name: "Soul Level 1" }
	],
	ds2sotfs: [
		{ id: "zdnwmlqd", name: "Old Souls" },
		{ id: "zd3ernkn", name: "All Bosses" },
		{ id: "xd11mjzd", name: "All Achievements" }
	],
	desremake: [
		{ id: "rkl3386k", name: "Any% Glitchless" },
		{ id: "z274l4g2", name: "Any% Force Quit" },
		{ id: "vdoxoj1d", name: "Any% SL1" },
		{ id: "9kv66ge2", name: "Offline Trophies" }
	]
};

// Get game ID from game name
const gameId = GAME_IDS[game.toLowerCase()] || game;

// Get categories for the current game
const categories = GAME_CATEGORIES[game.toLowerCase()] || [];

// Find the selected category (by ID or name)
const selectedCategory = category ? categories.find(cat => 
	cat.id === category || cat.name === category
) : null;

// Helper function to get platform names
const getPlatformName = async (platformId: string): Promise<string> => {
	try {
		const response = await fetch(`https://www.speedrun.com/api/v1/platforms/${platformId}`);
		if (response.ok) {
			const data = await response.json();
			return data.data.name || platformId;
		}
	} catch (error) {
		console.error('Error fetching platform name:', error);
	}
	return platformId;
};

// Fetch real data from Speedrun.com API
const getSpeedrunData = async (gameId: string, categoryId?: string): Promise<SpeedrunRun[]> => {
	try {
		// Build the API URL with filters
		const baseUrl = 'https://www.speedrun.com/api/v1/runs';
		const params = new URLSearchParams({
			game: gameId,
			status: 'verified', // Only show verified runs
			orderby: 'date',
			direction: 'desc',
			max: '20', // Limit to top 20 runs
			embed: 'players' // Embed full player information
		});
		
		// Add category filter if specified
		if (categoryId) {
			params.append('category', categoryId);
		}
		
		const response = await fetch(`${baseUrl}?${params}`);
		
		if (!response.ok) {
			console.error(`Failed to fetch data: ${response.status}`);
			return [];
		}
		
		const data = await response.json();
		
		// Debug: Log the first run to see the structure
		if (data.data && data.data.length > 0) {
			console.log('First run data:', JSON.stringify(data.data[0], null, 2));
		}
		
		// Transform the API response to our format
		const transformedRuns = [];
		
		for (const run of data.data) {
			// Extract player name(s)
			let playerName = 'Unknown';
			if (run.players && run.players.length > 0) {
				const players = run.players.map((p: any) => {
					if (p.rel === 'user' && p.names) {
						return p.names.international || p.names.japanese || 'Unknown';
					} else if (p.rel === 'guest' && p.name) {
						return p.name;
					}
					return 'Unknown';
				});
				playerName = players.join(', ');
			}
			
			// Format the time
			let formattedTime = 'Unknown';
			if (run.times) {
				// Try ingame time first, fall back to primary time if ingame is null
				let timeInSeconds = 0;
				if (run.times.ingame && run.times.ingame_t) {
					timeInSeconds = run.times.ingame_t;
				} else if (run.times.primary && run.times.primary_t) {
					timeInSeconds = run.times.primary_t;
				}
				
				if (timeInSeconds > 0) {
					const hours = Math.floor(timeInSeconds / 3600);
					const minutes = Math.floor((timeInSeconds % 3600) / 60);
					const seconds = timeInSeconds % 60;
					
					if (hours > 0) {
						formattedTime = `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
					} else {
						formattedTime = `${minutes}:${seconds.toString().padStart(2, '0')}`;
					}
				}
			}
			
			// Format the date
			let formattedDate = 'Unknown';
			if (run.date) {
				const date = new Date(run.date);
				formattedDate = date.toLocaleDateString();
			}
			
			// Get platform name
			let platformName = 'Unknown';
			if (run.system && run.system.platform) {
				platformName = await getPlatformName(run.system.platform);
			}
			
			transformedRuns.push({
				player: playerName,
				igt: formattedTime,
				date: formattedDate,
				platform: platformName
			});
		}
		
		return transformedRuns;
		
	} catch (error) {
		console.error('Error fetching speedrun data:', error);
		return [];
	}
};

let runs: SpeedrunRun[] = [];
try {
	runs = await getSpeedrunData(gameId, selectedCategory?.id);
} catch (error) {
	console.error('Failed to fetch speedrun data:', error);
	// Fallback to empty array - could also show an error message
}
---

	<div class="speedrun-table-container">
		<!-- Category selector if enabled and categories exist -->
		{showCategorySelector && categories.length > 0 && (
			<div class="category-selector">
				<label for="category-select">Category:</label>
				<select id="category-select" class="category-dropdown">
					<option value="" selected={!selectedCategory}>All Categories</option>
					{categories.map((cat: Category) => (
						<option value={cat.id} selected={selectedCategory?.id === cat.id}>
							{cat.name}
						</option>
					))}
				</select>
			</div>
		)}
		
		<div class="custom-table">
			<div class="table-header">
				<div class="header-cell">Pos.</div>
				<div class="header-cell">Player</div>
				<div class="header-cell">Date</div>
				<div class="header-cell">Platform</div>
				<div class="header-cell">IGT</div>
			</div>
			
			{runs.length > 0 ? (
				runs.map((run, index) => (
					<div class="table-row">
						<div class="table-cell position-cell">
							<span class={`position-number ${index === 0 ? 'gold' : index === 1 ? 'silver' : index === 2 ? 'bronze' : ''}`}>
								{index + 1}.
							</span>
						</div>
						<div class="table-cell">{run.player}</div>
						<div class="table-cell">{run.date}</div>
						<div class="table-cell">{run.platform}</div>
						<div class="table-cell">{run.igt}</div>
					</div>
				))
			) : (
				<div class="table-row">
					<div class="table-cell no-data" style="text-align: center; padding: 2rem;">
						No speedrun data available for this game/category.
					</div>
				</div>
			)}
		</div>
		
		<div style="background: var(--sl-color-gray-3); border-radius: 4px;">
			<a href="https://speedrun.com" target="_blank" rel="noopener noreferrer"><img src="/pages/assets/speedrun.svg" alt="Speedrun.com" style="height: 32px; width: auto;  padding: 0.5rem 1rem;" /></a>
		</div>
	</div>

<script>
	// Handle category selection
	document.addEventListener('DOMContentLoaded', () => {
		const categorySelect = document.getElementById('category-select') as HTMLSelectElement;
		if (categorySelect) {
			categorySelect.addEventListener('change', (e) => {
				const target = e.target as HTMLSelectElement;
				const selectedCategory = target.value;
				
				if (selectedCategory === '') {
					// All Categories selected
					console.log('Selected category: All Categories');
					// In a real implementation, you would fetch data for all categories
				} else {
					// Specific category selected
					console.log('Selected category:', selectedCategory);
					// In a real implementation, you would fetch data for the specific category
				}
				
				// You could also update the URL or trigger a page refresh with the new category
			});
		}
	});
</script>

<style>
	.category-selector {
		margin-bottom: 1rem;
		display: flex;
		align-items: center;
		gap: 0.5rem;
	}

	.custom-table {
		width: 100%;
		border-collapse: collapse;
		overflow-x: auto;
	}
	
	.table-header, .table-row {
		display: table-row;
		width: 100%;
	}
	
	.header-cell, .table-cell {
		display: table-cell;
		padding: 0.5rem;
		text-align: left;
		border-bottom: 1px solid var(--sl-color-gray-5);
	}
	
	.header-cell {
		font-weight: 600;
	}
	
	/* Make Player column expand to fill available space */
	.header-cell:nth-child(2), .table-cell:nth-child(2) {
		width: 100%;
		font-weight: 600;
	}
	
	/* Keep other columns at natural width */
	.header-cell:nth-child(1), .table-cell:nth-child(1) { /* Position */
		width: auto;
	}
	
	.header-cell:nth-child(3), .table-cell:nth-child(3) { /* Date */
		width: auto;
	}
	
	.header-cell:nth-child(4), .table-cell:nth-child(4) { /* Platform */
		width: auto;
	}
	
	.header-cell:nth-child(5), .table-cell:nth-child(5) { /* IGT */
		width: auto;
		text-align: right;
		padding-right: 1rem;
	}
	
	.position-number {
		font-weight: bold;
		color: var(--sl-color-gray-8);
	}
	
	.position-number.gold {
		color: gold;
	}
	
	.position-number.silver {
		color: silver;
	}
	
	.position-number.bronze {
		color: #cd7f32;
	}
	
	.no-data {
		text-align: center;
		padding: 2rem;
		color: var(--sl-color-gray-6);
		font-style: italic;
	}
</style>

